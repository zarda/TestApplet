//
// File generated by HDevelop for HALCON/.NET (C#) Version 13.0.1.1
//

using HalconDotNet;

public partial class HDevelopExport
{
#if !(NO_EXPORT_MAIN || NO_EXPORT_APP_MAIN)
    public HDevelopExport()
    {
        // Default settings used in HDevelop 
        HOperatorSet.SetSystem("width", 512);
        HOperatorSet.SetSystem("height", 512);
        if (HalconAPI.isWindows)
            HOperatorSet.SetSystem("use_window_thread", "true");
        action();
    }
#endif

    // Procedures 
    // External procedures 
    // Chapter: Develop
    // Short Description: Open a new graphics window that preserves the aspect ratio of the given image size. 
    public void dev_open_window_fit_size(HTuple hv_Row, HTuple hv_Column, HTuple hv_Width,
        HTuple hv_Height, HTuple hv_WidthLimit, HTuple hv_HeightLimit, out HTuple hv_WindowHandle)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_MinWidth = new HTuple(), hv_MaxWidth = new HTuple();
        HTuple hv_MinHeight = new HTuple(), hv_MaxHeight = new HTuple();
        HTuple hv_ResizeFactor = null, hv_TempWidth = null, hv_TempHeight = null;
        HTuple hv_WindowWidth = null, hv_WindowHeight = null;
        // Initialize local and output iconic variables 
        //This procedure open a new graphic window
        //such that it fits into the limits specified by WidthLimit
        //and HeightLimit, but also maintains the correct aspect ratio
        //given by Width and Height.
        //
        //If it is impossible to match the minimum and maximum extent requirements
        //at the same time (f.e. if the image is very long but narrow),
        //the maximum value gets a higher priority.
        //
        //Parse input tuple WidthLimit
        if ((int)((new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(0))).TupleOr(
            new HTuple(hv_WidthLimit.TupleLess(0)))) != 0)
        {
            hv_MinWidth = 500;
            hv_MaxWidth = 800;
        }
        else if ((int)(new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
            1))) != 0)
        {
            hv_MinWidth = 0;
            hv_MaxWidth = hv_WidthLimit.Clone();
        }
        else
        {
            hv_MinWidth = hv_WidthLimit.TupleSelect(0);
            hv_MaxWidth = hv_WidthLimit.TupleSelect(1);
        }
        //Parse input tuple HeightLimit
        if ((int)((new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(0))).TupleOr(
            new HTuple(hv_HeightLimit.TupleLess(0)))) != 0)
        {
            hv_MinHeight = 400;
            hv_MaxHeight = 600;
        }
        else if ((int)(new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
            1))) != 0)
        {
            hv_MinHeight = 0;
            hv_MaxHeight = hv_HeightLimit.Clone();
        }
        else
        {
            hv_MinHeight = hv_HeightLimit.TupleSelect(0);
            hv_MaxHeight = hv_HeightLimit.TupleSelect(1);
        }
        //
        //Test, if window size has to be changed.
        hv_ResizeFactor = 1;
        //First, expand window to the minimum extents (if necessary).
        if ((int)((new HTuple(hv_MinWidth.TupleGreater(hv_Width))).TupleOr(new HTuple(hv_MinHeight.TupleGreater(
            hv_Height)))) != 0)
        {
            hv_ResizeFactor = (((((hv_MinWidth.TupleReal()) / hv_Width)).TupleConcat((hv_MinHeight.TupleReal()
                ) / hv_Height))).TupleMax();
        }
        hv_TempWidth = hv_Width * hv_ResizeFactor;
        hv_TempHeight = hv_Height * hv_ResizeFactor;
        //Then, shrink window to maximum extents (if necessary).
        if ((int)((new HTuple(hv_MaxWidth.TupleLess(hv_TempWidth))).TupleOr(new HTuple(hv_MaxHeight.TupleLess(
            hv_TempHeight)))) != 0)
        {
            hv_ResizeFactor = hv_ResizeFactor * ((((((hv_MaxWidth.TupleReal()) / hv_TempWidth)).TupleConcat(
                (hv_MaxHeight.TupleReal()) / hv_TempHeight))).TupleMin());
        }
        hv_WindowWidth = hv_Width * hv_ResizeFactor;
        hv_WindowHeight = hv_Height * hv_ResizeFactor;
        //Resize window
        HOperatorSet.SetWindowAttr("background_color", "black");
        HOperatorSet.OpenWindow(hv_Row, hv_Column, hv_WindowWidth, hv_WindowHeight, 0, "visible", "", out hv_WindowHandle);
        HDevWindowStack.Push(hv_WindowHandle);
        if (HDevWindowStack.IsOpen())
        {
            HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_Height - 1, hv_Width - 1);
        }

        return;
    }

    // Chapter: Develop
    // Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
    public void dev_update_off()
    {

        // Initialize local and output iconic variables 
        //This procedure sets different update settings to 'off'.
        //This is useful to get the best performance and reduce overhead.
        //
        // dev_update_pc(...); only in hdevelop
        // dev_update_var(...); only in hdevelop
        // dev_update_window(...); only in hdevelop

        return;
    }

    // Chapter: Graphics / Text
    // Short Description: This procedure displays 'Click 'Run' to continue' in the lower right corner of the screen. 
    public void disp_continue_message(HTuple hv_WindowHandle, HTuple hv_Color, HTuple hv_Box)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_GenParamName = null, hv_GenParamValue = null;
        HTuple hv_ContinueMessage = null;
        HTuple hv_Color_COPY_INP_TMP = hv_Color.Clone();

        // Initialize local and output iconic variables 
        //This procedure displays 'Press Run (F5) to continue' in the
        //lower right corner of the screen.
        //It uses the procedure disp_message.
        //
        //Input parameters:
        //WindowHandle: The window, where the text shall be displayed
        //Color: defines the text color.
        //   If set to '' or 'auto', the currently set color is used.
        //Box: If set to 'true', the text is displayed in a box.
        //
        //Convert the parameter Box to generic parameters.
        hv_GenParamName = new HTuple();
        hv_GenParamValue = new HTuple();
        if ((int)(new HTuple((new HTuple(hv_Box.TupleLength())).TupleGreater(0))) != 0)
        {
            if ((int)(new HTuple(((hv_Box.TupleSelect(0))).TupleEqual("false"))) != 0)
            {
                //Display no box
                hv_GenParamName = hv_GenParamName.TupleConcat("box");
                hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
            }
            else if ((int)(new HTuple(((hv_Box.TupleSelect(0))).TupleNotEqual("true"))) != 0)
            {
                //Set a color other than the default.
                hv_GenParamName = hv_GenParamName.TupleConcat("box_color");
                hv_GenParamValue = hv_GenParamValue.TupleConcat(hv_Box.TupleSelect(0));
            }
        }
        if ((int)(new HTuple((new HTuple(hv_Box.TupleLength())).TupleGreater(1))) != 0)
        {
            if ((int)(new HTuple(((hv_Box.TupleSelect(1))).TupleEqual("false"))) != 0)
            {
                //Display no shadow.
                hv_GenParamName = hv_GenParamName.TupleConcat("shadow");
                hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
            }
            else if ((int)(new HTuple(((hv_Box.TupleSelect(1))).TupleNotEqual("true"))) != 0)
            {
                //Set a shadow color other than the default.
                hv_GenParamName = hv_GenParamName.TupleConcat("shadow_color");
                hv_GenParamValue = hv_GenParamValue.TupleConcat(hv_Box.TupleSelect(1));
            }
        }
        //
        if ((int)(new HTuple(hv_Color_COPY_INP_TMP.TupleEqual(""))) != 0)
        {
            //disp_text does not accept an empty string for Color.
            hv_Color_COPY_INP_TMP = new HTuple();
        }
        //
        //Display the message.
        hv_ContinueMessage = "Press Run (F5) to continue";
        //HOperatorSet.DispText(hv_WindowHandle, hv_ContinueMessage, "window", "bottom",
        //    "right", hv_Color_COPY_INP_TMP, hv_GenParamName, hv_GenParamValue);

        return;
    }

    // Chapter: Graphics / Text
    // Short Description: This procedure writes a text message. 
    public void disp_message(HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem,
        HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_GenParamName = null, hv_GenParamValue = null;
        HTuple hv_Color_COPY_INP_TMP = hv_Color.Clone();
        HTuple hv_Column_COPY_INP_TMP = hv_Column.Clone();
        HTuple hv_CoordSystem_COPY_INP_TMP = hv_CoordSystem.Clone();
        HTuple hv_Row_COPY_INP_TMP = hv_Row.Clone();

        // Initialize local and output iconic variables 
        //This procedure displays text in a graphics window.
        //
        //Input parameters:
        //WindowHandle: The WindowHandle of the graphics window, where
        //   the message should be displayed
        //String: A tuple of strings containing the text message to be displayed
        //CoordSystem: If set to 'window', the text position is given
        //   with respect to the window coordinate system.
        //   If set to 'image', image coordinates are used.
        //   (This may be useful in zoomed images.)
        //Row: The row coordinate of the desired text position
        //   A tuple of values is allowed to display text at different
        //   positions.
        //Column: The column coordinate of the desired text position
        //   A tuple of values is allowed to display text at different
        //   positions.
        //Color: defines the color of the text as string.
        //   If set to [], '' or 'auto' the currently set color is used.
        //   If a tuple of strings is passed, the colors are used cyclically...
        //   - if |Row| == |Column| == 1: for each new textline
        //   = else for each text position.
        //Box: If Box[0] is set to 'true', the text is written within an orange box.
        //     If set to' false', no box is displayed.
        //     If set to a color string (e.g. 'white', '#FF00CC', etc.),
        //       the text is written in a box of that color.
        //     An optional second value for Box (Box[1]) controls if a shadow is displayed:
        //       'true' -> display a shadow in a default color
        //       'false' -> display no shadow
        //       otherwise -> use given string as color string for the shadow color
        //
        //It is possible to display multiple text strings in a single call.
        //In this case, some restrictions apply:
        //- Multiple text positions can be defined by specifying a tuple
        //  with multiple Row and/or Column coordinates, i.e.:
        //  - |Row| == n, |Column| == n
        //  - |Row| == n, |Column| == 1
        //  - |Row| == 1, |Column| == n
        //- If |Row| == |Column| == 1,
        //  each element of String is display in a new textline.
        //- If multiple positions or specified, the number of Strings
        //  must match the number of positions, i.e.:
        //  - Either |String| == n (each string is displayed at the
        //                          corresponding position),
        //  - or     |String| == 1 (The string is displayed n times).
        //
        //
        //Convert the parameters for disp_text.
        if ((int)((new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
            new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(new HTuple())))) != 0)
        {

            return;
        }
        if ((int)(new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(-1))) != 0)
        {
            hv_Row_COPY_INP_TMP = 12;
        }
        if ((int)(new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(-1))) != 0)
        {
            hv_Column_COPY_INP_TMP = 12;
        }
        //
        //Convert the parameter Box to generic parameters.
        hv_GenParamName = new HTuple();
        hv_GenParamValue = new HTuple();
        if ((int)(new HTuple((new HTuple(hv_Box.TupleLength())).TupleGreater(0))) != 0)
        {
            if ((int)(new HTuple(((hv_Box.TupleSelect(0))).TupleEqual("false"))) != 0)
            {
                //Display no box
                hv_GenParamName = hv_GenParamName.TupleConcat("box");
                hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
            }
            else if ((int)(new HTuple(((hv_Box.TupleSelect(0))).TupleNotEqual("true"))) != 0)
            {
                //Set a color other than the default.
                hv_GenParamName = hv_GenParamName.TupleConcat("box_color");
                hv_GenParamValue = hv_GenParamValue.TupleConcat(hv_Box.TupleSelect(0));
            }
        }
        if ((int)(new HTuple((new HTuple(hv_Box.TupleLength())).TupleGreater(1))) != 0)
        {
            if ((int)(new HTuple(((hv_Box.TupleSelect(1))).TupleEqual("false"))) != 0)
            {
                //Display no shadow.
                hv_GenParamName = hv_GenParamName.TupleConcat("shadow");
                hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
            }
            else if ((int)(new HTuple(((hv_Box.TupleSelect(1))).TupleNotEqual("true"))) != 0)
            {
                //Set a shadow color other than the default.
                hv_GenParamName = hv_GenParamName.TupleConcat("shadow_color");
                hv_GenParamValue = hv_GenParamValue.TupleConcat(hv_Box.TupleSelect(1));
            }
        }
        //Restore default CoordSystem behavior.
        if ((int)(new HTuple(hv_CoordSystem_COPY_INP_TMP.TupleNotEqual("window"))) != 0)
        {
            hv_CoordSystem_COPY_INP_TMP = "image";
        }
        //
        if ((int)(new HTuple(hv_Color_COPY_INP_TMP.TupleEqual(""))) != 0)
        {
            //disp_text does not accept an empty string for Color.
            hv_Color_COPY_INP_TMP = new HTuple();
        }
        //
        //HOperatorSet.DispText(hv_WindowHandle, hv_String, hv_CoordSystem_COPY_INP_TMP,
        //    hv_Row_COPY_INP_TMP, hv_Column_COPY_INP_TMP, hv_Color_COPY_INP_TMP, hv_GenParamName,
        //    hv_GenParamValue);

        return;
    }

    // Chapter: Graphics / Text
    // Short Description: Set font independent of OS 
    public void set_display_font(HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font,
        HTuple hv_Bold, HTuple hv_Slant)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_OS = null, hv_Fonts = new HTuple();
        HTuple hv_Style = null, hv_Exception = new HTuple(), hv_AvailableFonts = null;
        HTuple hv_Fdx = null, hv_Indices = new HTuple();
        HTuple hv_Font_COPY_INP_TMP = hv_Font.Clone();
        HTuple hv_Size_COPY_INP_TMP = hv_Size.Clone();

        // Initialize local and output iconic variables 
        //This procedure sets the text font of the current window with
        //the specified attributes.
        //
        //Input parameters:
        //WindowHandle: The graphics window for which the font will be set
        //Size: The font size. If Size=-1, the default of 16 is used.
        //Bold: If set to 'true', a bold font is used
        //Slant: If set to 'true', a slanted font is used
        //
        HOperatorSet.GetSystem("operating_system", out hv_OS);
        // dev_get_preferences(...); only in hdevelop
        // dev_set_preferences(...); only in hdevelop
        if ((int)((new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
            new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(-1)))) != 0)
        {
            hv_Size_COPY_INP_TMP = 16;
        }
        if ((int)(new HTuple(((hv_OS.TupleSubstr(0, 2))).TupleEqual("Win"))) != 0)
        {
            //Restore previous behaviour
            hv_Size_COPY_INP_TMP = ((1.13677 * hv_Size_COPY_INP_TMP)).TupleInt();
        }
        if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("Courier"))) != 0)
        {
            hv_Fonts = new HTuple();
            hv_Fonts[0] = "Courier";
            hv_Fonts[1] = "Courier 10 Pitch";
            hv_Fonts[2] = "Courier New";
            hv_Fonts[3] = "CourierNew";
        }
        else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("mono"))) != 0)
        {
            hv_Fonts = new HTuple();
            hv_Fonts[0] = "Consolas";
            hv_Fonts[1] = "Menlo";
            hv_Fonts[2] = "Courier";
            hv_Fonts[3] = "Courier 10 Pitch";
            hv_Fonts[4] = "FreeMono";
        }
        else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("sans"))) != 0)
        {
            hv_Fonts = new HTuple();
            hv_Fonts[0] = "Luxi Sans";
            hv_Fonts[1] = "DejaVu Sans";
            hv_Fonts[2] = "FreeSans";
            hv_Fonts[3] = "Arial";
        }
        else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("serif"))) != 0)
        {
            hv_Fonts = new HTuple();
            hv_Fonts[0] = "Times New Roman";
            hv_Fonts[1] = "Luxi Serif";
            hv_Fonts[2] = "DejaVu Serif";
            hv_Fonts[3] = "FreeSerif";
            hv_Fonts[4] = "Utopia";
        }
        else
        {
            hv_Fonts = hv_Font_COPY_INP_TMP.Clone();
        }
        hv_Style = "";
        if ((int)(new HTuple(hv_Bold.TupleEqual("true"))) != 0)
        {
            hv_Style = hv_Style + "Bold";
        }
        else if ((int)(new HTuple(hv_Bold.TupleNotEqual("false"))) != 0)
        {
            hv_Exception = "Wrong value of control parameter Bold";
            throw new HalconException(hv_Exception);
        }
        if ((int)(new HTuple(hv_Slant.TupleEqual("true"))) != 0)
        {
            hv_Style = hv_Style + "Italic";
        }
        else if ((int)(new HTuple(hv_Slant.TupleNotEqual("false"))) != 0)
        {
            hv_Exception = "Wrong value of control parameter Slant";
            throw new HalconException(hv_Exception);
        }
        if ((int)(new HTuple(hv_Style.TupleEqual(""))) != 0)
        {
            hv_Style = "Normal";
        }
        HOperatorSet.QueryFont(hv_WindowHandle, out hv_AvailableFonts);
        hv_Font_COPY_INP_TMP = "";
        for (hv_Fdx = 0; (int)hv_Fdx <= (int)((new HTuple(hv_Fonts.TupleLength())) - 1); hv_Fdx = (int)hv_Fdx + 1)
        {
            hv_Indices = hv_AvailableFonts.TupleFind(hv_Fonts.TupleSelect(hv_Fdx));
            if ((int)(new HTuple((new HTuple(hv_Indices.TupleLength())).TupleGreater(0))) != 0)
            {
                if ((int)(new HTuple(((hv_Indices.TupleSelect(0))).TupleGreaterEqual(0))) != 0)
                {
                    hv_Font_COPY_INP_TMP = hv_Fonts.TupleSelect(hv_Fdx);
                    break;
                }
            }
        }
        if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual(""))) != 0)
        {
            throw new HalconException("Wrong value of control parameter Font");
        }
        hv_Font_COPY_INP_TMP = (((hv_Font_COPY_INP_TMP + "-") + hv_Style) + "-") + hv_Size_COPY_INP_TMP;
        HOperatorSet.SetFont(hv_WindowHandle, hv_Font_COPY_INP_TMP);
        // dev_set_preferences(...); only in hdevelop

        return;
    }

#if !NO_EXPORT_MAIN
    // Main procedure 
    private void action()
    {


        // Local iconic variables 

        HObject ho_Image = null, ho_ImageAffineTrans = null;

        // Local control variables 

        HTuple hv_WindowHandle = null, hv_DeviceIdentifier = null;
        HTuple hv_Index = null, hv_DeviceName = new HTuple(), hv_DeviceVendor = new HTuple();
        HTuple hv_Message = new HTuple(), hv_DeviceIndex = null;
        HTuple hv_DeviceHandle = new HTuple(), hv_HomMat2DIdentity = new HTuple();
        HTuple hv_HomMat2DScale = new HTuple(), hv_HomMat2D = new HTuple();
        HTuple hv_Loops = new HTuple(), hv_Before = new HTuple();
        HTuple hv_After = new HTuple(), hv_TimeGPU = new HTuple();
        HTuple hv_Grayval = new HTuple(), hv_Pointer = new HTuple();
        HTuple hv_Type = new HTuple(), hv_Width = new HTuple();
        HTuple hv_Height = new HTuple(), hv_TimeGPUinclTransfer = new HTuple();
        HTuple hv_TimeCPU = new HTuple(), hv_SpeedUp = new HTuple();
        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_Image);
        HOperatorSet.GenEmptyObj(out ho_ImageAffineTrans);
        try
        {
            //This example shows how to use compute devices with HALCON.
            //
            dev_update_off();
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.CloseWindow(HDevWindowStack.Pop());
            }
            dev_open_window_fit_size(0, 0, 640, 480, -1, -1, out hv_WindowHandle);
            set_display_font(hv_WindowHandle, 16, "mono", "true", "false");
            //
            //Get list of all available compute devices.
            HOperatorSet.QueryAvailableComputeDevices(out hv_DeviceIdentifier);
            //
            //End example if no device could be found.
            if ((int)(new HTuple((new HTuple(hv_DeviceIdentifier.TupleLength())).TupleEqual(
                0))) != 0)
            {
                ho_Image.Dispose();
                ho_ImageAffineTrans.Dispose();

                return;
            }
            //
            //Display basic information on detected devices.
            disp_message(hv_WindowHandle, new HTuple(new HTuple("Found ") + (new HTuple(hv_DeviceIdentifier.TupleLength()
                ))) + " Compute Device(s):", "window", 12, 12, "black", "true");
            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_DeviceIdentifier.TupleLength()
                )) - 1); hv_Index = (int)hv_Index + 1)
            {
                HOperatorSet.GetComputeDeviceInfo(hv_DeviceIdentifier.TupleSelect(hv_Index),
                    "name", out hv_DeviceName);
                HOperatorSet.GetComputeDeviceInfo(hv_DeviceIdentifier.TupleSelect(hv_Index),
                    "vendor", out hv_DeviceVendor);
                if (hv_Message == null)
                    hv_Message = new HTuple();
                hv_Message[hv_Index] = (((("Device #" + hv_Index) + ": ") + hv_DeviceVendor) + " ") + hv_DeviceName;
            }
            disp_message(hv_WindowHandle, hv_Message, "window", 42, 12, "white", "false");
            disp_continue_message(hv_WindowHandle, "black", "true");
            // stop(...); only in hdevelop
            //
            System.Threading.Thread.Sleep(2000);
            //Perform a small benchmark for all devices.
            for (hv_DeviceIndex = 0; (int)hv_DeviceIndex <= (int)((new HTuple(hv_DeviceIdentifier.TupleLength()
                )) - 1); hv_DeviceIndex = (int)hv_DeviceIndex + 1)
            {
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                }
                disp_message(hv_WindowHandle, ("Activating Device #" + hv_DeviceIndex) + " and performing benchmark...",
                    "window", 12, 12, "black", "true");
                //Open device.
                HOperatorSet.OpenComputeDevice(hv_DeviceIdentifier.TupleSelect(hv_DeviceIndex),
                    out hv_DeviceHandle);
                //Deactivate asynchronous execution to obtain reliable benchmarks.
                HOperatorSet.SetComputeDeviceParam(hv_DeviceHandle, "asynchronous_execution",
                    "false");
                //Call affine_trans_image on this device and measure the obtained speed-up.
                //Activate the compute device and perform the initialization of affine_trans_image.
                //If this is omitted, the initialization is performed with the first
                //call of affine_trans_image.
                HOperatorSet.InitComputeDevice(hv_DeviceHandle, "affine_trans_image");
                HOperatorSet.ActivateComputeDevice(hv_DeviceHandle);
                //create benchmark input data
                ho_Image.Dispose();
                HOperatorSet.ReadImage(out ho_Image, "rings_and_nuts");
                HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
                HOperatorSet.HomMat2dScale(hv_HomMat2DIdentity, 0.9, 0.9, 320, 240, out hv_HomMat2DScale);
                HOperatorSet.HomMat2dRotate(hv_HomMat2DScale, 0.78, 320, 240, out hv_HomMat2D);
                //Set number of benchmark loops.
                hv_Loops = 200;
                //One call to fill caches.
                ho_ImageAffineTrans.Dispose();
                HOperatorSet.AffineTransImage(ho_Image, out ho_ImageAffineTrans, hv_HomMat2D,
                    "constant", "false");
                HOperatorSet.CountSeconds(out hv_Before);
                HTuple end_val50 = hv_Loops;
                HTuple step_val50 = 1;
                for (hv_Index = 1; hv_Index.Continue(end_val50, step_val50); hv_Index = hv_Index.TupleAdd(step_val50))
                {
                    ho_ImageAffineTrans.Dispose();
                    HOperatorSet.AffineTransImage(ho_Image, out ho_ImageAffineTrans, hv_HomMat2D,
                        "constant", "false");
                }
                HOperatorSet.CountSeconds(out hv_After);
                hv_TimeGPU = ((hv_After - hv_Before) * 1000.0) / hv_Loops;
                //
                //Perform a slightly modified version of this benchmark to include
                //host->device and device->host transfer.
                HOperatorSet.GetGrayval(ho_Image, 0, 0, out hv_Grayval);
                ho_ImageAffineTrans.Dispose();
                HOperatorSet.AffineTransImage(ho_Image, out ho_ImageAffineTrans, hv_HomMat2D,
                    "constant", "false");
                HOperatorSet.CountSeconds(out hv_Before);
                HTuple end_val61 = hv_Loops;
                HTuple step_val61 = 1;
                for (hv_Index = 1; hv_Index.Continue(end_val61, step_val61); hv_Index = hv_Index.TupleAdd(step_val61))
                {
                    //set_grayval ensures that Image must be transferred to the device again.
                    HOperatorSet.SetGrayval(ho_Image, 0, 0, hv_Grayval);
                    ho_ImageAffineTrans.Dispose();
                    HOperatorSet.AffineTransImage(ho_Image, out ho_ImageAffineTrans, hv_HomMat2D,
                        "constant", "false");
                    //get_image_pointer1 ensures that ImageAffineTrans is transferred back to host.
                    HOperatorSet.GetImagePointer1(ho_ImageAffineTrans, out hv_Pointer, out hv_Type,
                        out hv_Width, out hv_Height);
                }
                HOperatorSet.CountSeconds(out hv_After);
                hv_TimeGPUinclTransfer = ((hv_After - hv_Before) * 1000.0) / hv_Loops;
                //
                //Deactivate the device and perform the same benchmark on the CPU.
                HOperatorSet.DeactivateComputeDevice(hv_DeviceHandle);
                ho_ImageAffineTrans.Dispose();
                HOperatorSet.AffineTransImage(ho_Image, out ho_ImageAffineTrans, hv_HomMat2D,
                    "constant", "false");
                HOperatorSet.CountSeconds(out hv_Before);
                HTuple end_val75 = hv_Loops;
                HTuple step_val75 = 1;
                for (hv_Index = 1; hv_Index.Continue(end_val75, step_val75); hv_Index = hv_Index.TupleAdd(step_val75))
                {
                    ho_ImageAffineTrans.Dispose();
                    HOperatorSet.AffineTransImage(ho_Image, out ho_ImageAffineTrans, hv_HomMat2D,
                        "constant", "false");
                }
                HOperatorSet.CountSeconds(out hv_After);
                hv_TimeCPU = ((hv_After - hv_Before) * 1000.0) / hv_Loops;
                hv_SpeedUp = hv_TimeCPU / hv_TimeGPU;
                hv_Message = "affine_trans_image runtimes:";
                if (hv_Message == null)
                    hv_Message = new HTuple();
                hv_Message[1] = ((("Compute Device #" + hv_DeviceIndex) + " (excl. transfer): ") + (hv_TimeGPU.TupleString(
                    ".2f"))) + " ms";
                if (hv_Message == null)
                    hv_Message = new HTuple();
                hv_Message[2] = ((("Compute Device #" + hv_DeviceIndex) + " (incl. transfer): ") + (hv_TimeGPUinclTransfer.TupleString(
                    ".2f"))) + " ms";
                if (hv_Message == null)
                    hv_Message = new HTuple();
                hv_Message[3] = ("CPU:                                " + (hv_TimeCPU.TupleString(
                    ".2f"))) + " ms";
                if (hv_Message == null)
                    hv_Message = new HTuple();
                hv_Message[4] = " ";
                if (hv_Message == null)
                    hv_Message = new HTuple();
                hv_Message[5] = "Potential speedup: " + (hv_SpeedUp.TupleString(".1f"));
                disp_message(hv_WindowHandle, hv_Message, "window", 42, 12, "white", "false");
                if ((int)(new HTuple(hv_DeviceIndex.TupleLess((new HTuple(hv_DeviceIdentifier.TupleLength()
                    )) - 1))) != 0)
                {
                    disp_continue_message(hv_WindowHandle, "black", "true");
                    // stop(...); only in hdevelop
                    
                }
                System.Threading.Thread.Sleep(2000);
            }
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_Image.Dispose();
            ho_ImageAffineTrans.Dispose();

            throw HDevExpDefaultException;
        }
        ho_Image.Dispose();
        ho_ImageAffineTrans.Dispose();

    }

#endif


}
#if !(NO_EXPORT_MAIN || NO_EXPORT_APP_MAIN)
public class HDevelopExportApp
{
    static void Main(string[] args)
    {
        new HDevelopExport();
    }
}
#endif

